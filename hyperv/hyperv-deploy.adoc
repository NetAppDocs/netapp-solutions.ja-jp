---
sidebar: sidebar 
permalink: hyperv/hyperv-deploy.html 
keywords: hyperv, hyper-v, deploy, netapp, virtualization 
summary: 解決策には、Hyper-VをNetAppストレージに導入するために必要な手順が記載されている 
---
= NetAppストレージへのMicrosoft Hyper-Vの導入
:hardbreaks:
:allow-uri-read: 
:nofooter: 
:icons: font
:linkattrs: 
:imagesdir: ./../media/


[role="lead"]
Windows Serverプラットフォームは、Hyper-Vの役割を使用して仮想化テクノロジを提供します。Hyper-Vは、Windows Serverで提供される多くのオプションの役割の1つです。



== 概要

Hyper-Vの役割により、Windows Serverに組み込まれている仮想化テクノロジを使用して、仮想化コンピューティング環境を作成および管理できます。Hyper-Vテクノロジは、ハードウェアを仮想化して、1台の物理コンピュータ上で複数のオペレーティングシステムを同時に実行できる環境を提供します。Hyper-Vでは、仮想マシンとそのリソースを作成および管理できます。各仮想マシンは、独立した仮想化されたコンピュータシステムであり、独自のオペレーティングシステムを実行できます。Hyper-Vは、効率の向上とコスト削減を目的としたさまざまなビジネス目標をサポートするアプリケーションとワークロードを仮想化するためのインフラストラクチャを提供します。これは、VMware®vSphereの最適な代替手段です。特に、現在の市場状況において、複数のハイパーバイザの共存を求める組織に適しています。



== 対象者

このドキュメントでは、NetApp ONTAPシステムを使用するHyper-Vクラスタ構成のアーキテクチャと導入手順について説明します。このドキュメントの対象読者は、セールスエンジニア、フィールドコンサルタント、プロフェッショナルサービス、ITマネージャー、パートナーエンジニア、 また、プライマリまたは代替のハイパーバイザーとしてHyper-Vを導入したいと考えているお客様もいます。



== アーキテクチャ

本ドキュメントで説明するアーキテクチャには、特にMicrosoft®Windows Server®2022とHyper-V®仮想化が含まれています。NetAppでは、すべての導入に仮想化ソフトウェアとインフラ管理ソフトウェアを使用することを強く推奨しています。この構成では、各コンポーネントのベストプラクティスを使用して、信頼性の高いエンタープライズクラスのインフラを実現します。



== ユースケースの概要

本ドキュメントでは、NetAppオールフラッシュFASおよびASAアレイモデルを使用して、Microsoft Windows Server 2022でワークロードとして最適なパフォーマンスを発揮するようにHyper-Vクラスタをセットアップするための導入手順とベストプラクティスについて説明します。サーバのオペレーティングシステム/ハイパーバイザーはMicrosoft Windows Server 2022です。このガイダンスでは、Storage Area Network（SAN；ストレージエリアネットワーク）プロトコルとNetwork-Attached Storage（NAS；ネットワーク接続型ストレージ）プロトコルでデータを提供するNetAppストレージシステムを対象としています。



== Deployment手順

このトピックでは、ONTAPストレージシステムを活用して、2ノードのフェイルオーバークラスタとクラスタ化されたHyper-V仮想マシンを設定および導入する手順について説明します。



=== 手順導入の前提条件

* すべてのハードウェアは、実行しているWindows Serverのバージョンに対して認定されている必要があります。また、完全なフェイルオーバークラスタ解決策は、構成の検証ウィザードのすべてのテストに合格する必要があります。
* ドメインコントローラに追加されたHyper-Vノード（推奨）と、相互に適切に接続されている。
* すべてのHyper-Vノードを同一の構成にする必要があります。
* 管理、iSCSI、SMB、ライブ移行用に分離されたトラフィック用に各Hyper-Vサーバに設定されたネットワークアダプタと専用仮想スイッチ。
* フェイルオーバークラスタ機能は、各Hyper-Vサーバで有効になっています。
* SMB共有（CSV）は、Hyper-VクラスタリングのためにVMとそのディスクを格納する共有ストレージとして使用されます。
* 異なるクラスタ間でストレージを共有しないでください。クラスタごとに1つまたは複数のCSV / CIFS共有を計画します。
* SMB共有を共有ストレージとして使用する場合は、SMB共有に対する権限を設定して、クラスタ内のすべてのHyper-Vノードのコンピュータアカウントにアクセスを許可する必要があります。


詳細については、を参照してください

* link:https://learn.microsoft.com/en-us/windows-server/virtualization/hyper-v/system-requirements-for-hyper-v-on-windows#how-to-check-for-hyper-v-requirements["Windows Server上のHyper-Vのシステム要件"]
* link:https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/jj134244(v=ws.11)#step-1-prepare-to-validate-hardware-for-a-failover-cluster["フェールオーバークラスタのハードウェアの検証"]
* link:https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/jj863389(v=ws.11)["Hyper-Vクラスタの導入"]


.Windows機能のインストール
[%collapsible]
====
次の手順では、必要なWindows Server 2022機能をインストールする方法について説明します。

*すべてのホスト*

. 指定されたすべてのノードで、必要な更新とデバイスドライバを使用してWindows OS 2022を準備します。
. インストール時に入力した管理者パスワードを使用して、各Hyper-Vノードにログインします。
. タスクバーのPowerShellアイコンを右クリックし、 `Run as Administrator`。
. Hyper-V、MPIO、およびクラスタリング機能を追加します。
+
[source, cli]
----
Add-WindowsFeature Hyper-V, Failover-Clustering, Multipath-IO `-IncludeManagementTools –Restart
----


====
.ネットワークの設定
[%collapsible]
====
フォールトトレラント展開を実現するには、適切なネットワーク計画が重要です。フェイルオーバークラスタの標準的な推奨事項は、トラフィックのタイプごとに個別の物理ネットワークアダプタを設定することでした。仮想ネットワークアダプタを追加したり、組み込みのチーミング（セット）を切り替えたり、Hyper-V QoSなどの機能を導入したりすることで、ネットワークトラフィックをより少ない物理アダプタで処理できるようになりました。QoS、冗長性、およびトラフィック分離を念頭に置いて、ネットワーク構成を設計します。VLANなどのネットワーク分離技術をトラフィック分離技術と組み合わせて設定すると、トラフィックの冗長性とサービス品質が確保され、ストレージトラフィックのパフォーマンスが向上し、一貫性が向上します。

複数の論理ネットワークや物理ネットワークを使用して、特定のワークロードを分離して分離することを推奨します。一般的にセグメントに分割される一般的なネットワークトラフィックの例を次に示します。

* iSCSIストレージネットワーク：
* CSV（クラスタ共有ボリューム）またはハートビートネットワーク。
* ライブマイグレーション
* VM ネットワーク
* 管理ネットワーク



NOTE: iSCSIを専用NICで使用する場合は、チーミング解決策の使用は推奨されないため、MPIO / DSMを使用する必要があります。


NOTE: Hyper-Vネットワークのベストプラクティスでも、Hyper-V環境でSMB 3.0ストレージネットワークにNICチーミングを使用することは推奨されていません。

追加情報については、を参照してください。 link:https://learn.microsoft.com/en-us/windows-server/virtualization/hyper-v/plan/plan-hyper-v-networking-in-windows-server["Windows ServerでのHyper-Vネットワークの計画"]

====
.Hyper-Vのストレージ設計の決定
[%collapsible]
====
Hyper-Vは、仮想マシンのバッキングストレージとしてNAS（SMB3.0）とブロックストレージ（iSCSI / FC）をサポートしています。NetAppはSMB3.0、iSCSI、およびFCプロトコルをサポートしており、iSCSI / FCおよびSMB3を使用してVM - Cluster Shared Volume（CSV；クラスタ共有ボリューム）のネイティブストレージとして使用できます。また、SMB3とiSCSIを、ストレージへの直接アクセスが必要なワークロード向けのゲスト接続ストレージオプションとして使用することもできます。ONTAPでは、SAN専用構成向けにプロトコルアクセスとSAN向けに最適化されたストレージ（オールSANアレイ）を混在させる必要があるワークロード向けに、ユニファイドストレージ（オールフラッシュアレイ）の柔軟なオプションを提供します。

iSCSI / FCではなくSMB3を使用するかどうかは、現在導入されている既存のインフラストラクチャによって決定されます。SMB3 / iSCSIを使用すると、お客様は既存のネットワークインフラストラクチャを使用できます。既存のFCインフラをお持ちのお客様は、そのインフラを活用して、FCベースのクラスタ共有ボリュームとしてストレージを提供できます。

*注：* ONTAPソフトウェアを実行するNetAppストレージコントローラは、Hyper-V環境で次のワークロードをサポートできます。

* 継続的可用性を備えたSMB 3.0共有でホストされるVM
* iSCSIまたはFCで実行されているCluster Shared Volume（CSV；クラスタ共有ボリューム）LUNでホストされているVM
* ゲスト内ストレージとゲスト仮想マシンへのディスクのパススルー



NOTE: シンプロビジョニング、重複排除、圧縮、データコンパクション、フレックスクローンONTAP、 スナップショットとレプリケーションは、プラットフォームやオペレーティングシステムに関係なく、バックグラウンドでシームレスに機能し、Hyper-Vワークロードに大きな価値をもたらします。これらの機能のデフォルト設定は、Windows ServerおよびHyper-Vに最適です。


NOTE: ゲストVMへのパスが複数あり、マルチパスI/O機能がインストールおよび設定されている場合は、ゲスト内イニシエータを使用してMPIOがサポートされます。


NOTE: ONTAP は、業界標準の主要なクライアントプロトコルであるNFS、SMB、FC、FCoE、iSCSIをすべてサポートしています。 NVMe/FCおよびS3。ただし、MicrosoftではNVMe/FCとNVMe/TCPはサポートされていません。

====
.NetApp Windows iSCSI Host Utilitiesのインストール
[%collapsible]
====
次のセクションでは、NetApp Windows iSCSI Host Utilitiesの無人インストール方法について説明します。インストールの詳細については、を参照してください。 link:https://docs.netapp.com/us-en/ontap-sanhost/hu_wuhu_72.html["Windows Unified Host Utilities 7.2（またはサポート対象の最新バージョン）をインストールする"]

*すべてのホスト*

. ダウンロード link:https://mysupport.netapp.com/site/products/all/details/hostutilities/downloads-tab/download/61343/7.2["Windows iSCSI Host Utilities"]
. ダウンロードしたファイルのブロックを解除します。
+
[source, cli]
----
Unblock-file ~\Downloads\netapp_windows_host_utilities_7.2_x64.msi
----
. Host Utilitiesをインストールします。
+
[source, cli]
----
~\Downloads\netapp_windows_host_utilities_7.2_x64.msi /qn "MULTIPATHING=1"
----



NOTE: このプロセス中にシステムが再起動します。

====
.WindowsホストのiSCSIイニシエータの設定
[%collapsible]
====
次の手順では、組み込みのMicrosoft iSCSIイニシエータを設定する方法について説明します。

*すべてのホスト*

. タスクバーのPowerShellアイコンを右クリックして[Run as Administrator]を選択し、PowerShellプロンプトを起動します。
. iSCSIサービスが自動的に開始されるように設定します。
+
[source, cli]
----
Set-Service -Name MSiSCSI -StartupType Automatic
----
. iSCSIサービスを開始します。
+
[source, cli]
----
Start-Service -Name MSiSCSI
----
. すべてのiSCSIデバイスを要求するようにMPIOを設定します。
+
[source, cli]
----
Enable-MSDSMAutomaticClaim -BusType iSCSI
----
. 新しく要求されたすべてのデバイスのデフォルトのロードバランシングポリシーをラウンドロビンに設定します。
+
[source, cli]
----
Set-MSDSMGlobalDefaultLoadBalancePolicy -Policy RR 
----
. コントローラごとにiSCSIターゲットを設定します。
+
[source, cli]
----
New-IscsiTargetPortal -TargetPortalAddress <<iscsia_lif01_ip>> -InitiatorPortalAddress <iscsia_ipaddress>

New-IscsiTargetPortal -TargetPortalAddress <<iscsib_lif01_ip>> -InitiatorPortalAddress <iscsib_ipaddress

New-IscsiTargetPortal -TargetPortalAddress <<iscsia_lif02_ip>> -InitiatorPortalAddress <iscsia_ipaddress>

New-IscsiTargetPortal -TargetPortalAddress <<iscsib_lif02_ip>> -InitiatorPortalAddress <iscsib_ipaddress>
----
. 各iSCSIネットワークのセッションを各ターゲットに接続します。
+
[source, cli]
----
Get-IscsiTarget | Connect-IscsiTarget -IsPersistent $true -IsMultipathEnabled $true -InitiatorPo rtalAddress <iscsia_ipaddress>

Get-IscsiTarget | Connect-IscsiTarget -IsPersistent $true -IsMultipathEnabled $true -InitiatorPo rtalAddress <iscsib_ipaddress>
----



NOTE: パフォーマンスを向上させ、帯域幅を活用するために、複数のセッション（最小5～8）を追加します。

====
.クラスタの作成
[%collapsible]
====
*サーバ1台のみ*

. PowerShellアイコンを右クリックし、 `Run as Administrator``。
. 新しいクラスタを作成します。
+
[source, cli]
----
New-Cluster -Name <cluster_name> -Node <hostnames> -NoStorage -StaticAddress <cluster_ip_address>
----
+
image:hyperv-deploy-image01.png["クラスタ管理インターフェイスを示す画像"]

. ライブマイグレーションに適したクラスタネットワークを選択します。
. CSVネットワークを指定します。
+
[source, cli]
----
(Get-ClusterNetwork -Name Cluster).Metric = 900
----
. クォーラムディスクを使用するようにクラスタを変更します。
+
.. PowerShellアイコンを右クリックし、[Run as Administrator]を選択して、管理者権限でPowerShellプロンプトを起動します。
+
[source, cli]
----
start-ClusterGroup "Available Storage"| Move-ClusterGroup -Node $env:COMPUTERNAME
----
.. フェイルオーバークラスタマネージャで、 `Configure Cluster Quorum Settings`。
+
image:hyperv-deploy-image02.png["クラスタクォーラム設定の構成の画像"]

.. [Welcome]ページで[Next]をクリックします。
.. クォーラム監視を選択し、[Next]をクリックします。
.. [Configure a disk witness]を選択し、[Next]をクリックします。
.. 使用可能なストレージから[Disk W:]を選択し、[Next]をクリックします。
.. 確認ページで[Next]をクリックし、概要ページで[Finish]をクリックします。
+
クォーラムと監視の詳細については、を参照してください。 link:https://learn.microsoft.com/en-us/windows-server/failover-clustering/manage-cluster-quorum#general-recommendations-for-quorum-configuration["クォーラムの設定と管理"]



. フェイルオーバークラスタマネージャからクラスタ検証ウィザードを実行して、導入を検証します。
. フェイルオーバークラスタマネージャ内のロールを使用して、仮想マシンデータを格納するCSV LUNを作成し、可用性の高い仮想マシンを作成します。


====


== 考慮事項、機能、および統合



=== 考慮すべき要素

この手順は、Hyper-V環境でアプリケーション、サービス、ワークロードが効果的に動作することを確認するために不可欠です。互換性チェックには、オペレーティングシステムのバージョン、Windowsサーバのバージョン、アプリケーションの依存関係、データベースシステム、および既存の環境に存在する特定の構成やカスタマイズが含まれている必要があります。

.ストレージの適切なサイジング
[%collapsible]
====
ワークロードを導入する前、または既存のハイパーバイザーから移行する前に、必要なパフォーマンスを満たすようにワークロードがサイジングされていることを確認してください。これは、個 々 のVMのパフォーマンスデータを収集して、CPU（使用済み/プロビジョニング済み）、メモリ（使用済み/プロビジョニング済み）、ストレージ（プロビジョニング済み/利用済み）、ネットワークスループット、レイテンシ、および読み取り/書き込みIOPS、スループット、ブロックサイズの集計を行うことで簡単に実現できます。これらのパラメータは、導入を成功させるため、およびストレージアレイとワークロードホストのサイズを正しく設定するためには必須です。


NOTE: Hyper-Vおよび関連するワークロードのストレージをサイジングする際に、IOPSと容量を計画します。


NOTE: I/O負荷の高いVMや、大量のリソースと容量を必要とするVMの場合は、OSとデータディスクを分離します。オペレーティングシステムやアプリケーションのバイナリは頻繁に変更されず、ボリュームのクラッシュ整合性も許容されます。


NOTE: VHDを使用する場合よりも、ハイパフォーマンスデータディスクにはゲスト接続ストレージ（ゲスト内ストレージ）を使用します。これは、クローン作成プロセスを簡単にするのにも役立ちます。

====
.仮想マシンのパフォーマンスの向上
[%collapsible]
====
最適なパフォーマンスを得るには、適切なRAMとvCPUの容量を選択し、複数のディスクを単一の仮想SCSIコントローラに接続します。導入時の仮想ディスクの主な選択肢として固定VHDxを使用することが引き続き推奨されます。また、どのタイプのVHDX仮想ディスクの使用にも制限はありません。


NOTE: 使用されない不要な役割をWindows Serverにインストールしないでください。


NOTE: SCSIコントローラからVMをロードできる仮想マシンの世代としてGen2を選択します。これはブートレベルのVMBusおよびVSP/VSCアーキテクチャに基づいているため、VMの全体的なパフォーマンスが大幅に向上します。


NOTE: VMのパフォーマンスに悪影響を及ぼすため、チェックポイントを頻繁に作成することは避けてください。

====
.SMB3.0の設計と検討事項
[%collapsible]
====
SMB 3.0ファイル共有をHyper-V用の共有ストレージとして使用できます。ONTAPでは、Hyper-VのSMB共有を介したノンストップオペレーションがサポートされます。Hyper-Vでは、SMBファイル共有を使用して、構成、スナップショット、仮想ハードディスク（VHD）ファイルなどの仮想マシンファイルを格納できます。Hyper-VのSMB3.0ベースの共有には専用のONTAP CIFS SVMを使用します。仮想マシンファイルの格納に使用するボリュームは、NTFSセキュリティ形式のボリュームで作成する必要があります。10GBのネットワークがある場合は、Hyper-VホストとNetAppアレイの間の接続を推奨します。1GBのネットワーク接続の場合、NetAppでは、複数の1GBポートで構成されるインターフェイスグループを作成することを推奨します。SMBマルチチャネルを提供する各NICを専用のIPサブネットに接続し、各サブネットがクライアントとサーバの間に単一のパスを提供するようにします。

キーポイント

* ONTAP SVMでのSMBマルチチャネルの有効化
* ONTAP CIFS SVMには、クラスタ内の各ノードに少なくとも1つのデータLIFが必要です。
* 使用する共有にcontinuously-availableプロパティが設定されている必要があります。
* ONTAP Oneは、すべてのAFF（AシリーズおよびCシリーズ）、All-SAN Array（ASA）、およびFASシステムに含まれるようになりました。したがって、個別のライセンスは必要ありません。
* 共有VHDxの場合は、ゲスト接続iSCSI LUNを使用



NOTE: ODXはサポートされており、複数のプロトコルにわたって機能します。ファイル共有とiSCSIまたはFCP接続LUNの間でデータをコピーする場合も、ODXが使用されます。


NOTE: クラスタ内のノードの時間設定は、それに応じて設定する必要があります。NetApp CIFSサーバがWindows Active Directory（AD）ドメインに参加する必要がある場合は、ネットワークタイムプロトコル（NTP）を使用する必要があります。


NOTE: CIFSサーバを介してLarge MTU値を有効にする必要があります。パケットサイズが小さいと、パフォーマンスが低下する可能性があります。

====
.SMBボリュームのプロビジョニング
[%collapsible]
====
. Storage Virtual Machine（SVM）で必要なCIFSサーバオプションが有効になっていることを確認する
. 次のオプションをtrueに設定する必要があります。smb2-enabled smb3-enabled copy-offload-enabled shadowcopy-enabled is-multichannel-enabled is-large-mtu-enabled
+
image:hyperv-deploy-image03.png["SMBカラム設定の画像"]

. Storage Virtual Machine（SVM）にNTFSデータボリュームを作成し、Hyper-Vで使用する継続的可用性を備えた共有を設定する
+
image:hyperv-deploy-image04.png["NTFSデータボリューム設定のイメージ"]

+

NOTE: Hyper-V over SMBのノンストップオペレーションは、この構成で使用するボリュームをNTFSセキュリティ形式のボリュームとして作成しないかぎり、正しく機能しません。

. 継続的可用性を有効にし、共有のNTFS権限を設定して、Hyper-Vノードを完全に制御できるようにします。
+
image:hyperv-deploy-image05.png["NTFS権限設定の画像"]



ベストプラクティスの詳細なガイダンスについては、を参照してください。 link:https://docs.netapp.com/us-en/ontap-apps-dbs/microsoft/win_overview.html["Hyper-Vの導入ガイドラインとベストプラクティス"]。

追加情報については、を参照してください。 link:https://docs.netapp.com/us-en/ontap/smb-hyper-v-sql/server-volume-requirements-hyper-v-concept.html["Hyper-V over SMB 用の SMB サーバとボリュームの要件
"]。

====
.ブロックプロトコルの設計と考慮事項
[%collapsible]
====
キーポイント

* ホストでマルチパス（MPIO）を使用して、複数のパスを管理します。データ移動処理を容易にするため、または追加のI/Oリソースを活用するために、必要に応じてパスを追加します。ただし、ホストOSがサポートできるパスの最大数を超えないようにしてください。
* LUNにアクセスするホストにHost Utilities Kitをインストールします。
* 少なくとも8つのボリュームを作成します。



NOTE: ボリュームごとに1つのLUNを使用し、LUNとCSVの比率が1：1にマッピングされます。

* SVMには、iSCSIまたはファイバチャネルを使用してデータを提供するすべてのストレージコントローラ上のイーサネットネットワークまたはファイバチャネルファブリックごとに1つのLIFが必要です。
* FCPまたはiSCSIを使用してデータを提供するSVMには、SVM管理インターフェイスが必要です。


====
.iSCSIボリュームのプロビジョニング
[%collapsible]
====
iSCSIボリュームをプロビジョニングするには、次の前提条件を満たしていることを確認してください。

* Storage Virtual Machine（SVM）でiSCSIプロトコルを有効にし、適切な論理インターフェイス（LIF）を作成しておく必要があります。
* 指定したアグリゲートには、LUNを格納できるだけの十分な空きスペースが必要です。



NOTE: ONTAP では、デフォルトで選択的 LUN マップ（ SLM ）を使用して、 LUN を所有するノードとそのハイアベイラビリティ（ HA ）パートナーのパス経由でのみ LUN にアクセスできるようにします。

* LUNがクラスタ内の別のノードに移動された場合にLUNを使用できるように、すべてのノードのすべてのiSCSI LIFを設定します。


* 手順 *

. System Managerを使用して[LUN]ウィンドウに移動します（ONTAP CLIも同じ処理に使用できます）。
. Create をクリックします。 .
. 指定したLUNを作成するSVMを参照して選択し、LUN作成ウィザードが表示されます。
. [General Properties]ページで、Hyper-V仮想マシンの仮想ハードディスク（VHD）を含むLUNの場合は[Hyper-V]を選択します。
+
image:hyperv-deploy-image06.png["Hyper-V LUNを作成するための[General Properties]ページの画像"]

. <[More options]をクリックします。[LUN Container]ページで、既存のFlexVolボリュームを選択します。選択しないと、新しいボリュームが作成されます。
. <その他のオプションをクリック>[Initiators Mapping]ページで[Add Initiator Group]をクリックし、[General]タブで必要な情報を入力し、[Initiators]タブでホストのiSCSIイニシエータノード名を入力します。
. 詳細を確認し、[終了]をクリックしてウィザードを完了します。


LUNが作成されたら、フェイルオーバークラスタマネージャに移動します。ディスクをCSVに追加するには、そのディスクをクラスタのAvailable Storageグループに追加し（まだ追加されていない場合）、そのディスクをクラスタのCSVに追加する必要があります。


NOTE: CSV機能は、フェールオーバークラスタリングでデフォルトで有効になっています。

*使用可能なストレージへのディスクの追加：*

. フェイルオーバークラスタマネージャのコンソールツリーで、クラスタの名前を展開し、[Storage]を展開します。
. [Disks]を右クリックし、[Add Disk]を選択します。フェイルオーバークラスタで使用するために追加できるディスクのリストが表示されます。
. 追加するディスクを選択し、[OK]を選択します。
. これで、ディスクがAvailable Storageグループに割り当てられました。
. 完了したら、[Available Storage]に割り当てたディスクを選択し、選択したディスクを右クリックして[Add to Cluster Shared Volumes]を選択します。
+
image:hyperv-deploy-image07.png["[Add to Cluster Shared Volumes]インターフェイスの画像"]

. これで、ディスクがクラスタ内のクラスタ共有ボリュームグループに割り当てられました。ディスクは、%SystemDrive%ClusterStorageフォルダの下の番号付きボリューム（マウントポイント）として各クラスタノードに公開されます。ボリュームがCSVFSファイルシステムに表示されます。


追加情報については、を参照してください。 link:https://learn.microsoft.com/en-us/windows-server/failover-clustering/failover-cluster-csvs#add-a-disk-to-csv-on-a-failover-cluster["フェイルオーバークラスタでのクラスタ共有ボリュームの使用"]。

*高可用性仮想マシンの作成：*

高可用性仮想マシンを作成するには、次の手順を実行します。

. フェイルオーバークラスタマネージャで、目的のクラスタを選択または指定します。クラスタの下のコンソールツリーが展開されていることを確認します。
. [Roles]をクリックします。
. [操作]ペインで、[仮想マシン]をクリックし、[新しい仮想マシン]をクリックします。[New Virtual Machine Wizard]が表示されます。次へをクリックします。
. [Specify Name and Location]ページで、仮想マシンの名前（nimdemoなど）を指定します。[Store the virtual machine in a different location]をクリックして完全パスを入力するか、[Browse]をクリックして共有ストレージに移動します。
. 物理ネットワークアダプタに関連付けられた仮想スイッチにメモリを割り当て、ネットワークアダプタを設定します。
. [Connect Virtual Hard Disk]ページで、[Create a virtual hard disk]をクリックします。
. [Installation Options]ページで、[Install an operating system from a boot CD/DVD-ROM]をクリックします。[メディア]で、メディアの場所を指定し、[完了]をクリックします。
. 仮想マシンが作成されます。フェイルオーバークラスタマネージャの高可用性ウィザードにより、仮想マシンの高可用性が自動的に設定されます。


====
.ODX機能を使用した仮想ディスクの高速プロビジョニング
[%collapsible]
====
ONTAPのODX機能を使用すると、ONTAPストレージシステムでホストされているマスターVHDXファイルをコピーするだけで、マスターVHDXのコピーを作成できます。ODX対応のコピーではネットワーク回線にデータが配置されないため、NetAppストレージ側でコピープロセスが実行されるため、最大で6~8倍の時間が短縮されます。高速プロビジョニングの一般的な考慮事項には、ファイル共有に格納されたマスターsysprepイメージや、Hyper-Vホストマシンによって開始される通常のコピープロセスなどがあります。


NOTE: ONTAPでは、SMBプロトコルとSANプロトコルの両方でODXがサポートされます。


NOTE: Hyper-VでのODXコピーオフロードのパススルーのユースケースを利用するには、ゲストオペレーティングシステムでODXがサポートされている必要があります。また、ゲストオペレーティングシステムのディスクが、ODXをサポートするストレージ（SMBまたはSAN）から作成されたSCSIディスクである必要があります。ゲストオペレーティングシステムのディスクが IDE ディスクの場合、 ODX のパススルーはサポートされません。

====
.パフォーマンスの最適化
[%collapsible]
====
CSVあたりの推奨VM数は主観的なものですが、CSVまたはSMBの各ボリュームに配置できるVMの最適数は、さまざまな要因によって決まります。ほとんどの管理者は容量のみを考慮しますが、VHDxに送信される同時I/Oの量は、全体的なパフォーマンスの最も重要な要因の1つです。パフォーマンスを制御する最も簡単な方法は、CSVまたは共有ごとに配置される仮想マシンの数を規制することです。仮想マシンの同時I/OパターンからCSVまたは共有に大量のトラフィックが送信されると、ディスクキューがいっぱいになり、レイテンシが高くなります。

====
.SMBボリュームとCSVのサイジング
[%collapsible]
====
ボトルネックを回避するために解決策のサイズがエンドツーエンドで適切に設定されていることを確認し、Hyper-V VMストレージ用にボリュームを作成する場合は、必要以上のサイズのボリュームを作成することを推奨します。ボリュームのサイズを適正化することで、CSV上に誤って多数の仮想マシンが配置されるのを防ぎ、リソース競合の可能性を低減できます。各クラスタ共有ボリューム（CSV）では、1つまたは複数のVMがサポートされます。CSVに配置するVMの数は、ワークロードやビジネスの設定、およびSnapshotやレプリケーションなどのONTAPストレージ機能の使用方法によって決まります。ほとんどの導入シナリオでは、複数のVMをCSVに配置することを推奨します。パフォーマンスとデータ保護の要件に合わせて、特定のユースケースに合わせてこのアプローチを調整してください。

ボリュームとVHDxのサイズは簡単に拡張できるため、VMで追加の容量が必要になった場合でも、CSVのサイズを必要以上に設定する必要はありません。Diskpartを使用してCSVサイズを拡張することも、新しいCSVを作成して必要なVMを新しいCSVに移行することもできます。最適なパフォーマンスを得るためには、中間的な手段としてCSVのサイズを増やすのではなく、CSVの数を増やすことを推奨します。

====
.データ移行
[%collapsible]
====
現在の市場状況で最も一般的なユースケースの1つは、移行です。VMMファブリックまたはその他のサードパーティの移行ツールを使用して、VMを移行できます。これらのツールでは、ホストレベルのコピーを使用して、ソースプラットフォームからデスティネーションプラットフォームにデータを移動します。移行の対象となる仮想マシンの数によっては、時間がかかる場合があります。

このようなシナリオでONTAPを使用すると、ホストベースの移行プロセスよりも迅速に移行できます。また、ONTAPでは、ハイパーバイザー間でVMを迅速に移行できます（この場合はESXiからHyper-V）。NetAppストレージでは、任意のサイズのVMDKを数秒でVHDxに変換できます。これがPowerShellの方法です。NetApp FlexClone®テクノロジを活用して、VMのハードディスクを迅速に変換します。また、ターゲットVMとデスティネーションVMの作成と設定も行います。

このプロセスにより、ダウンタイムが最小限に抑えられ、ビジネスの生産性が向上します。また、ライセンスコスト、ロックイン、単一ベンダーへのコミットメントを削減することで、選択肢と柔軟性を提供します。これは、VMのライセンスコストを最適化し、IT予算を拡大したいと考えている組織にとっても有益です。

追加情報でFlexCloneとPowerShellを使用した移行については、を参照してください。 link:#appendix["付録A"]。

====


=== データ保護

.NetAppストレージスナップショットを使用したリストア
[%collapsible]
====
VMのバックアップと迅速なリカバリやクローニングは、ONTAPボリュームの大きな強みです。Snapshotコピーを使用すると、パフォーマンスに影響を与えることなく、VMやCSVボリューム全体のFlexCloneコピーを迅速に作成できます。これにより、本番データボリュームのクローンを作成し、QA環境、ステージング環境、および開発環境にマウントする際に、データ破損のリスクを伴わずに本番データを扱うことができます。FlexCloneボリュームは、データのコピーに必要なスペースを2倍にすることなく、本番環境のデータのテストコピーを作成する場合に便利です。

Hyper-Vノードは各ディスクに一意のIDを割り当て、それぞれのパーティション（MBRまたはGPT）を持つボリュームのSnapshotを作成すると、同じ一意のIDが使用されることに注意してください。MBRはディスクシグネチャを使用し、GPTはGUID（Global Unique Identifier）を使用します。スタンドアロンのHyper-Vホストの場合、FlexCloneボリュームは競合することなく簡単にマウントできます。これは、スタンドアロンのHyper-Vサーバでは、重複するディスクIDを自動的に検出し、ユーザの介入なしに動的に変更できるためです。このアプローチでは、シナリオに応じてVHDをコピーすることでVMをリカバリできます。

スタンドアロンのHyper-Vホストの場合は簡単ですが、Hyper-Vクラスタの場合は手順が異なります。リカバリプロセスでは、FlexCloneボリュームをスタンドアロンのHyper-Vホストにマッピングするか、diskpartを使用して、FlexCloneボリュームをスタンドアロンのHyper-Vホストにマッピングして署名を手動で変更します（ディスクIDの競合によりディスクをオンラインにできなくなるため、この処理は重要です）。 FlexCloneボリュームをクラスタにマッピング

====
.サードパーティの解決策を使用したバックアップとリストア
[%collapsible]
====

NOTE: このセクションではCommVaultを使用していますが、これは他のサードパーティソリューションにも適用されます。

Commvault IntelliSnap®は、ONTAPスナップショットを活用してハードウェアベースのスナップショットを作成
構成を変更します。バックアップは、Hyper-VハイパーバイザーまたはVMグループの設定に基づいて自動化することも、VMグループまたは特定のVMに対して手動で自動化することもできます。IntelliSnapを使用すると、Hyper-V環境を迅速に保護し、本番仮想化ファームへの負荷を最小限に抑えることができます。IntelliSnapテクノロジと仮想サーバエージェント（VSA）の統合により、NetApp ONTAPアレイは、多数の仮想マシンとデータストアを使用してわずか数分でバックアップを完了できます。きめ細かなアクセスにより、フルゲスト.vhdファイルとともに、セカンダリストレージ階層から個 々 のファイルやフォルダをリカバリできます。

仮想化環境を構成する前に'スナップショットとアレイの統合を必要とする適切なエージェントを導入しますMicrosoft Hyper-V仮想化環境では、次のエージェントが必要です。

* MediaAgent
* 仮想サーバエージェント（VSA）
* VSSハードウェアプロバイダ（Windows Server 2012以降のオペレーティングシステム）


*アレイ管理を使用したNetAppアレイの構成*

次の手順では、ONTAPアレイとHyper-Vを使用する環境でIntelliSnap仮想マシンのバックアップを設定する方法を示します。

. CommCell Consoleのリボンで、[Storage]タブをクリックし、[Array Management]をクリックします。
. [Array Management]ダイアログボックスが表示されます。
. 追加をクリックします。
+
[Array Properties]ダイアログボックスが表示されます。

+
image:hyperv-deploy-image09.png["Array Properties（アレイのプロパティ）ダイアログの画像"]

. [全般]タブで、次の情報を指定します。
. [Snap Vendor]リストから、NetAppを選択します。
. [名前]ボックスに、プライマリファイルサーバのホスト名、完全修飾ドメイン名（FQDN）、またはTCP/IPアドレスを入力します。
. [Array Access Nodes]タブで、[Available media agents]を選択します。
. [スナップ構成（Snap Configuration）]タブで、必要に応じて[スナップショット構成プロパティ（Snapshot Configuration Properties）]を構成します。
. [OK] をクリックします。
. <Mandatory step>完了したら、[検出]オプションを使用してNetAppストレージアレイでSVMを設定してStorage Virtual Machine（SVM）を自動的に検出し、SVMを選択します。追加オプションを使用して、そのSVMをCommServeデータベースにアレイ管理エントリとして追加します。
+
image:hyperv-deploy-image10.png["アレイ管理エントリとしてSVMを設定するイメージ"]

. [Advanced]（詳細設定）をクリックし（下図を参照）、[Enable IntelliSnap（IntelliSnapを有効にする）]チェックボックスを選択します。
+
image:hyperv-deploy-image11.png["[IntelliSnapを有効にする]オプションを表示している画像"]



アレイの設定手順の詳細については、を参照してください。 link:https://documentation.commvault.com/11.20/configuring_netapp_array_using_array_management.html["NetAppアレイの設定"] および link:https://cvdocssaproduction.blob.core.windows.net/cvdocsproduction/2023e/expert/configuring_storage_virtual_machines_on_netapp_arrays.html["NetAppアレイでのStorage Virtual Machineの設定"]

*ハイパーバイザーとしてHyper-Vを追加*

次の手順では、Hyper-Vハイパーバイザーを追加し、VMグループを追加します。

前提条件

* ハイパーバイザーには、Hyper-Vクラスタ、クラスタ内のHyper-Vサーバ、またはスタンドアロンのHyper-Vサーバを使用できます。
* ユーザは、Hyper-V Server 2012以降のHyper-V管理者グループに属している必要があります。Hyper-Vクラスタの場合、ユーザアカウントには完全なクラスタ権限（読み取りとフルコントロール）が必要です。
* バックアップおよびリストア処理用のアクセスノード（VSAプロキシ）を作成するためにVirtual Server Agent（VSA）をインストールするノードを1つ以上指定します。Hyper-Vサーバを検出するには、CommServeシステムにVSAがインストールされている必要があります。
* Hyper-V 2012 R2でChanged Block Trackingを使用するには、Hyper-Vクラスタ内のすべてのノードを選択します。


次の手順では、Hyper-Vをハイパーバイザーとして追加する方法を示します。

. コアのセットアップが完了したら、[保護]タブで[仮想化]タイルをクリックします。
. [Create server backup plan]ページで、プランの名前を入力し、ストレージ、保持、およびバックアップスケジュールに関する情報を入力します。
. [Add hypervisor（ハイパーバイザーの追加）]ページが表示されたら、[Select vendor：Select Hyper-V（IPアドレスまたはFQDNとユーザクレデンシャルを入力）]を選択します。
. Hyper-Vサーバの場合は、[ノードの検出]をクリックします。[Nodes]フィールドに値が入力されたら、Virtual Server Agentをインストールするノードを1つ以上選択します。
+
image:hyperv-deploy-image12.png["Hyper-Vノードの検出を示す画像"]

. [Next]をクリックし、[Save]をクリックします。
+
image:hyperv-deploy-image13.png["前の手順の結果を示す図"]

. [Add VM group]ページで、保護する仮想マシンを選択し（この例ではDemogrpを作成します）、次に示すようにIntelliSnapオプションを有効にします。
+
image:hyperv-deploy-image14.png["保護するVMの選択を示す画像"]

+

NOTE: VMグループでIntelliSnapが有効になっている場合、CommVaultはプライマリ（スナップ）コピーとバックアップコピーのスケジュールポリシーを自動的に作成します。

. [ 保存 ] をクリックします .


アレイの設定手順の詳細については、を参照してください。 link:https://documentation.commvault.com/2023e/essential/guided_setup_for_hyper_v.html["ハイパーバイザーの追加"]。

*バックアップの実行：*

. ナビゲーションペインで、[Protect]>[Virtualization]の順に選択します。[Virtual Machines]ページが表示されます。
. VMまたはVMグループをバックアップします。このデモでは、VMグループが選択されています。VMグループの行で、アクションボタンaction_buttonをクリックし、[Back up]を選択します。この場合、nimplanはDemogrpとDemogrp01に関連する計画です。
+
image:hyperv-deploy-image15.png["バックアップするVMを選択するダイアログを示す図"]

. バックアップが正常に完了すると、スクリーンショットに示されているように復元ポイントが使用可能になります。スナップコピーから、VM全体のリストアとゲストファイルとフォルダのリストアを実行できます。
+
image:hyperv-deploy-image16.png["バックアップの復元ポイントを示す画像"]

+

NOTE: 重要で使用率の高い仮想マシンについては、CSVごとに保持する仮想マシンの数を減らす



*リストア処理の実行：*

リストアポイントを使用して、完全なVM、ゲストファイルおよびフォルダ、または仮想ディスクファイルをリストアします。

. ナビゲーションペインで[Protect]>[Virtualization]に移動すると、[Virtual Machines]ページが表示されます。
. [VM groups]タブをクリックします。
. [VM group]ページが表示されます。
. [VM groups]領域で、仮想マシンを含むVMグループの[Restore]をクリックします。
. [Select restore type]ページが表示されます。
+
image:hyperv-deploy-image17.png["バックアップのリストアタイプを示す図"]

. 選択内容に応じて[Guest files]または[Full virtual machine]を選択し、リストアを実行します。
+
image:hyperv-deploy-image18.png["リストアのオプションを示す画像"]



サポートされるすべてのリストアオプションの詳細な手順については、を参照してください。 link:https://documentation.commvault.com/2023e/essential/restores_for_hyper_v.html["Hyper-Vヨウノリストア"]。

====


=== NetApp ONTAPの詳細オプション

NetApp SnapMirrorを使用すると、サイト間のストレージレプリケーションが効率的になり、災害が発生する
今日のグローバル企業に適した、迅速で信頼性と管理性に優れたリカバリを実現します。LANおよびWAN経由でデータを高速でレプリケートするSnapMirrorは、ミッションクリティカルなアプリケーションの高可用性と高速リカバリを実現するとともに、優れたストレージ重複排除機能とネットワーク圧縮機能を提供します。NetApp SnapMirrorテクノロジを使用すると、ディザスタリカバリによってデータセンター全体を保護できます。ボリュームはオフサイトの場所に段階的にバックアップできます。SnapMirrorは、必要なRPO（目標復旧時点）に応じて、ブロックベースの差分レプリケーションを実行します。ブロックレベルの更新により、必要な帯域幅と時間が削減され、DRサイトでデータの整合性が維持されます。

重要な手順は、データセット全体の1回限りのベースライン転送を作成することです。これは、差分更新を実行する前に必要です。この処理には、ソースでSnapshotコピーを作成し、コピーによって参照されるすべてのデータブロックをデスティネーションファイルシステムに転送する処理が含まれます。初期化が完了したら、スケジュールされた更新または手動でトリガーされた更新を実行できます。各更新では、新しいブロックと変更されたブロックだけがソースファイルシステムからデスティネーションファイルシステムに転送されます。この処理では、ソースボリュームにSnapshotコピーを作成し、ベースラインコピーと比較し、変更されたブロックのみをデスティネーションボリュームに転送します。新しいコピーが次回の更新のベースラインコピーになります。レプリケーションは定期的に行われるため、SnapMirrorは変更されたブロックを統合してネットワーク帯域幅を節約できます。書き込みスループットと書き込みレイテンシへの影響は最小限です。

リカバリは、次の手順を実行して実行します。

. セカンダリサイトのストレージシステムに接続します。
. SnapMirror関係を解除
. SnapMirrorボリューム内のLUNを、セカンダリサイトのHyper-Vサーバのイニシエータグループ（igroup）にマッピングします。
. LUNをHyper-Vクラスタにマッピングしたら、これらのディスクをオンラインにします。
. フェイルオーバークラスタのPowerShellコマンドレットを使用して、使用可能なストレージにディスクを追加し、CSVに変換します。
. CSV内の仮想マシンをHyper-Vマネージャにインポートし、高可用性を確保してから、クラスタに追加します。
. VMの電源をオンにします。




== まとめ

ONTAPは、さまざまなITワークロードを導入するのに最適な共有ストレージ基盤です。ONTAP AFFまたはASAプラットフォームは、複数のユースケースやアプリケーションに対応できる柔軟性と拡張性を備えています。このドキュメントで説明する仮想化解決策という一般的なユースケースの1つに、Windows Server 2022とHyper-Vが搭載されています。ONTAPストレージおよび関連機能の柔軟性と拡張性により、お客様は適切なサイズのストレージレイヤから始めて、進化するビジネス要件に合わせて拡張し、適応することができます。現在の市場状況では、Hyper-Vは、VMwareが提供していた機能のほとんどを提供する、最適な代替ハイパーバイザーオプションを提供します。



== 付録A：FlexCloneとPowerShellを使用した移行

.PowerShellスクリプト
[%collapsible]
====
[source, powershell]
----
param (
    [Parameter(Mandatory=$True, HelpMessage="VCenter DNS name or IP Address")]
    [String]$VCENTER,
    [Parameter(Mandatory=$True, HelpMessage="NetApp ONTAP NFS Datastore name")]
    [String]$DATASTORE,
    [Parameter(Mandatory=$True, HelpMessage="VCenter credentials")]
    [System.Management.Automation.PSCredential]$VCENTER_CREDS,
    [Parameter(Mandatory=$True, HelpMessage="The IP Address of the ONTAP Cluster")]
    [String]$ONTAP_CLUSTER,
    [Parameter(Mandatory=$True, HelpMessage="NetApp ONTAP VServer/SVM name")]
    [String]$VSERVER,
    [Parameter(Mandatory=$True, HelpMessage="NetApp ONTAP NSF,SMB Volume name")]
    [String]$ONTAP_VOLUME_NAME,
    [Parameter(Mandatory=$True, HelpMessage="ONTAP NFS/CIFS Volume mount Drive on Hyper-V host")]
    [String]$ONTAP_NETWORK_SHARE_ADDRESS,
    [Parameter(Mandatory=$True, HelpMessage="NetApp ONTAP Volume QTree folder name")]
    [String]$VHDX_QTREE_NAME,
    [Parameter(Mandatory=$True, HelpMessage="The Credential to connect to the ONTAP Cluster")]
    [System.Management.Automation.PSCredential]$ONTAP_CREDS,
    [Parameter(Mandatory=$True, HelpMessage="Hyper-V VM switch name")]
    [String]$HYPERV_VM_SWITCH
)

function main {

    ConnectVCenter

    ConnectONTAP

    GetVMList

    GetVMInfo

    #PowerOffVMs

    CreateOntapVolumeSnapshot

    Shift

    ConfigureVMsOnHyperV
}

function ConnectVCenter {
    Write-Host "------------------------------------------------------------------------------" -ForegroundColor Cyan
    Write-Host "Connecting to vCenter $VCENTER" -ForegroundColor Magenta
    Write-Host "------------------------------------------------------------------------------`n" -ForegroundColor Cyan

    [string]$vmwareModuleName = "VMware.VimAutomation.Core"

    Write-Host "Importing VMware $vmwareModuleName Powershell module"
    if ((Get-Module|Select-Object -ExpandProperty Name) -notcontains $vmwareModuleName) {
        Try {
            Import-Module $vmwareModuleName -ErrorAction Stop
            Write-Host "$vmwareModuleName imported successfully" -ForegroundColor Green
        } Catch {
            Write-Error "Error: $vmwareMdouleName PowerShell module not found"
			break;
        }
    }
    else {
        Write-Host "$vmwareModuleName Powershell module already imported" -ForegroundColor Green
    }

    Write-Host "`nConnecting to vCenter $VCENTER"
    Try {
        $connect = Connect-VIServer -Server $VCENTER -Protocol https -Credential $VCENTER_CREDS -ErrorAction Stop
        Write-Host "Connected to vCenter $VCENTER" -ForegroundColor Green
    } Catch {
        Write-Error "Failed to connect to vCenter $VCENTER. Error : $($_.Exception.Message)"
		break;
    }
}

function ConnectONTAP {
    Write-Host "`n------------------------------------------------------------------------------" -ForegroundColor Cyan
    Write-Host "Connecting to VSerevr $VSERVER at ONTAP Cluster $ONTAP_CLUSTER" -ForegroundColor Magenta
    Write-Host "------------------------------------------------------------------------------`n" -ForegroundColor Cyan

    [string]$ontapModuleName = "NetApp.ONTAP"

    Write-Host "Importing NetApp ONTAP $ontapModuleName Powershell module"
    if ((Get-Module|Select-Object -ExpandProperty Name) -notcontains $ontapModuleName) {
        Try {
            Import-Module $ontapModuleName -ErrorAction Stop
            Write-Host "$ontapModuleName imported successfully" -ForegroundColor Green
        } Catch {
            Write-Error "Error: $vmwareMdouleName PowerShell module not found"
			break;
        }
    }
    else {
        Write-Host "$ontapModuleName Powershell module already imported" -ForegroundColor Green
    }

    Write-Host "`nConnecting to ONTAP Cluster $ONTAP_CLUSTER"
    Try {
        $connect = Connect-NcController -Name $ONTAP_CLUSTER -Credential $ONTAP_CREDS -Vserver $VSERVER
        Write-Host "Connected to ONTAP Cluster $ONTAP_CLUSTER" -ForegroundColor Green
    } Catch {
        Write-Error "Failed to connect to ONTAP Cluster $ONTAP_CLUSTER. Error : $($_.Exception.Message)"
		break;
    }
}

function GetVMList {
    Write-Host "`n------------------------------------------------------------------------------" -ForegroundColor Cyan
    Write-Host "Fetching powered on VMs list with Datastore $DATASTORE" -ForegroundColor Magenta
    Write-Host "------------------------------------------------------------------------------`n" -ForegroundColor Cyan
    try {
        $vmList = VMware.VimAutomation.Core\Get-VM -Datastore $DATASTORE -ErrorAction Stop| Where-Object {$_.PowerState -eq "PoweredOn"} | OUT-GridView -OutputMode Multiple
        #$vmList = Get-VM -Datastore $DATASTORE -ErrorAction Stop| Where-Object {$_.PowerState -eq "PoweredOn"}

        if($vmList) {
            Write-Host "Selected VMs for Shift" -ForegroundColor Green
            $vmList | Format-Table -Property Name
            $Script:VMList = $vmList
        }
        else {
            Throw "No VMs selected"
        }
    }
    catch {
        Write-Error "Failed to get VM List. Error : $($_.Exception.Message)"
        Break;
    }
}

function GetVMInfo {
    Write-Host "------------------------------------------------------------------------------" -ForegroundColor Cyan
    Write-Host "VM Information" -ForegroundColor Magenta
    Write-Host "------------------------------------------------------------------------------" -ForegroundColor Cyan
    $vmObjArray = New-Object System.Collections.ArrayList

    if($VMList) {
        foreach($vm in $VMList) {
            $vmObj = New-Object -TypeName System.Object

            $vmObj | Add-Member -MemberType NoteProperty -Name ID -Value $vm.Id
            $vmObj | Add-Member -MemberType NoteProperty -Name Name -Value $vm.Name
            $vmObj | Add-Member -MemberType NoteProperty -Name NumCpu -Value $vm.NumCpu
            $vmObj | Add-Member -MemberType NoteProperty -Name MemoryGB -Value $vm.MemoryGB
            $vmObj | Add-Member -MemberType NoteProperty -Name Firmware -Value $vm.ExtensionData.Config.Firmware

            $vmDiskInfo = $vm | VMware.VimAutomation.Core\Get-HardDisk

            $vmDiskArray = New-Object System.Collections.ArrayList
            foreach($disk in $vmDiskInfo) {
                $diskObj = New-Object -TypeName System.Object

                $diskObj | Add-Member -MemberType NoteProperty -Name Name -Value $disk.Name

                $fileName = $disk.Filename
                if ($fileName -match '\[(.*?)\]') {
                    $dataStoreName = $Matches[1]
                }

                $parts = $fileName -split " "
                $pathParts = $parts[1] -split "/"
                $folderName = $pathParts[0]
                $fileName = $pathParts[1]

                $diskObj | Add-Member -MemberType NoteProperty -Name DataStore -Value $dataStoreName
                $diskObj | Add-Member -MemberType NoteProperty -Name Folder -Value $folderName
                $diskObj | Add-Member -MemberType NoteProperty -Name Filename -Value $fileName
                $diskObj | Add-Member -MemberType NoteProperty -Name CapacityGB -Value $disk.CapacityGB

                $null = $vmDiskArray.Add($diskObj)
            }

            $vmObj | Add-Member -MemberType NoteProperty -Name PrimaryHardDisk -Value "[$($vmDiskArray[0].DataStore)] $($vmDiskArray[0].Folder)/$($vmDiskArray[0].Filename)"
            $vmObj | Add-Member -MemberType NoteProperty -Name HardDisks -Value $vmDiskArray

            $null = $vmObjArray.Add($vmObj)

            $vmNetworkArray = New-Object System.Collections.ArrayList

            $vm |
            ForEach-Object {
              $VM = $_
              $VM | VMware.VimAutomation.Core\Get-VMGuest | Select-Object -ExpandProperty Nics |
              ForEach-Object {
                $Nic = $_
                foreach ($IP in $Nic.IPAddress)
                {
                  if ($IP.Contains('.'))
                  {
                    $networkObj = New-Object -TypeName System.Object

                    $vlanId = VMware.VimAutomation.Core\Get-VirtualPortGroup | Where-Object {$_.Key -eq $Nic.NetworkName}
                    $networkObj | Add-Member -MemberType NoteProperty -Name VLanID -Value $vlanId
                    $networkObj | Add-Member -MemberType NoteProperty -Name IPv4Address -Value $IP

                    $null = $vmNetworkArray.Add($networkObj)
                  }
                }
              }
            }

            $vmObj | Add-Member -MemberType NoteProperty -Name PrimaryIPv4 -Value $vmNetworkArray[0].IPv4Address
            $vmObj | Add-Member -MemberType NoteProperty -Name PrimaryVLanID -Value $vmNetworkArray.VLanID
            $vmObj | Add-Member -MemberType NoteProperty -Name Networks -Value $vmNetworkArray

            $guest = $vm.Guest
            $parts = $guest -split ":"
            $afterColon = $parts[1]

            $osFullName = $afterColon

            $vmObj | Add-Member -MemberType NoteProperty -Name OSFullName -Value $osFullName
            $vmObj | Add-Member -MemberType NoteProperty -Name GuestID -Value $vm.GuestId
        }
    }

    $vmObjArray | Format-Table -Property ID, Name, NumCpu, MemoryGB, PrimaryHardDisk, PrimaryIPv4, PrimaryVLanID, GuestID, OSFullName, Firmware

    $Script:VMObjList = $vmObjArray
}

function PowerOffVMs {
    Write-Host "`n------------------------------------------------------------------------------" -ForegroundColor Cyan
    Write-Host "Power Off VMs" -ForegroundColor Magenta
    Write-Host "------------------------------------------------------------------------------`n" -ForegroundColor Cyan
    foreach($vm in $VMObjList) {
        try {
            Write-Host "Powering Off VM $($vm.Name) in vCenter $($VCENTER)"
            $null = VMware.VimAutomation.Core\Stop-VM -VM $vm.Name -Confirm:$false -ErrorAction Stop
            Write-Host "Powered Off VM $($vm.Name)" -ForegroundColor Green
        }
        catch {
            Write-Error "Failed to Power Off VM $($vm.Name). Error : $._Exception.Message"
            Break;
        }
        Write-Host "`n"
    }
}

function CreateOntapVolumeSnapshot {
    Write-Host "`n------------------------------------------------------------------------------" -ForegroundColor Cyan
    Write-Host "Taking ONTAP Snapshot for Volume $ONTAP_VOLUME_NAME" -ForegroundColor Magenta
    Write-Host "------------------------------------------------------------------------------`n" -ForegroundColor Cyan

    Try {
        Write-Host "Taking snapshot for Volume $ONTAP_VOLUME_NAME"
        $timestamp = Get-Date -Format "yyyy-MM-dd_HHmmss"
        $snapshot = New-NcSnapshot -VserverContext $VSERVER -Volume $ONTAP_VOLUME_NAME -Snapshot "snap.script-$timestamp"

        if($snapshot) {
            Write-Host "Snapshot ""$($snapshot.Name)"" created for Volume $ONTAP_VOLUME_NAME" -ForegroundColor Green
            $Script:OntapVolumeSnapshot = $snapshot
        }
    } Catch {
        Write-Error "Failed to create snapshot for Volume $ONTAP_VOLUME_NAME. Error : $_.Exception.Message"
        Break;
    }
}

function Shift {
    Write-Host "------------------------------------------------------------------------------" -ForegroundColor Cyan
    Write-Host "VM Shift" -ForegroundColor Magenta
    Write-Host "------------------------------------------------------------------------------`n" -ForegroundColor Cyan

    $Script:HypervVMList = New-Object System.Collections.ArrayList
    foreach($vmObj in $VMObjList) {

        Write-Host "***********************************************"
        Write-Host "Performing VM conversion for $($vmObj.Name)" -ForegroundColor Blue
        Write-Host "***********************************************"

        $hypervVMObj = New-Object -TypeName System.Object

        $directoryName = "/vol/$($ONTAP_VOLUME_NAME)/$($VHDX_QTREE_NAME)/$($vmObj.HardDisks[0].Folder)"

        try {
            Write-Host "Creating Folder ""$directoryName"" for VM $($vmObj.Name)"
            $dir = New-NcDirectory -VserverContext $VSERVER -Path $directoryName -Permission 0777 -Type directory -ErrorAction Stop
            if($dir) {
                Write-Host "Created folder ""$directoryName"" for VM $($vmObj.Name)`n" -ForegroundColor Green
            }
        }
        catch {
            if($_.Exception.Message -eq "[500]: File exists") {
                Write-Warning "Folder ""$directoryName"" already exists!`n"
            }
            Else {
                Write-Error "Failed to create folder ""$directoryName"" for VM $($vmObj.Name). Error : $($_.Exception.Message)"
                Break;
            }
        }

        $vmDiskArray = New-Object System.Collections.ArrayList

        foreach($disk in $vmObj.HardDisks) {
            $vmDiskObj = New-Object -TypeName System.Object
            try {
                Write-Host "`nConverting $($disk.Name)"
                Write-Host "--------------------------------"

                $vmdkPath = "/vol/$($ONTAP_VOLUME_NAME)/$($disk.Folder)/$($disk.Filename)"
                $fileName = $disk.Filename -replace '\.vmdk$', ''
                $vhdxPath = "$($directoryName)/$($fileName).vhdx"

                Write-Host "Converting ""$($disk.Name)"" VMDK path ""$($vmdkPath)"" to VHDX at Path ""$($vhdxPath)"" for VM $($vmObj.Name)"
                $convert = ConvertTo-NcVhdx -SourceVmdk $vmdkPath -DestinationVhdx $vhdxPath  -SnapshotName $OntapVolumeSnapshot -ErrorAction Stop -WarningAction SilentlyContinue
                if($convert) {
                    Write-Host "Successfully converted VM ""$($vmObj.Name)"" VMDK path ""$($vmdkPath)"" to VHDX at Path ""$($vhdxPath)""" -ForegroundColor Green

                    $vmDiskObj | Add-Member -MemberType NoteProperty -Name Name -Value $disk.Name
                    $vmDiskObj | Add-Member -MemberType NoteProperty -Name VHDXPath -Value $vhdxPath

                    $null = $vmDiskArray.Add($vmDiskObj)
                }
            }
            catch {
                Write-Error "Failed to convert ""$($disk.Name)"" VMDK to VHDX for VM $($vmObj.Name). Error : $($_.Exception.Message)"
                Break;
            }
        }

        $hypervVMObj | Add-Member -MemberType NoteProperty -Name Name -Value $vmObj.Name
        $hypervVMObj | Add-Member -MemberType NoteProperty -Name HardDisks -Value $vmDiskArray
        $hypervVMObj | Add-Member -MemberType NoteProperty -Name MemoryGB -Value $vmObj.MemoryGB
        $hypervVMObj | Add-Member -MemberType NoteProperty -Name Firmware -Value $vmObj.Firmware
        $hypervVMObj | Add-Member -MemberType NoteProperty -Name GuestID -Value $vmObj.GuestID



        $null = $HypervVMList.Add($hypervVMObj)
        Write-Host "`n"

    }
}

function ConfigureVMsOnHyperV {
    Write-Host "------------------------------------------------------------------------------" -ForegroundColor Cyan
    Write-Host "Configuring VMs on Hyper-V" -ForegroundColor Magenta
    Write-Host "------------------------------------------------------------------------------`n" -ForegroundColor Cyan

    foreach($vm in $HypervVMList) {
        try {

            # Define the original path
            $originalPath = $vm.HardDisks[0].VHDXPath
            # Replace forward slashes with backslashes
            $windowsPath = $originalPath -replace "/", "\"

            # Replace the initial part of the path with the Windows drive letter
            $windowsPath = $windowsPath -replace "^\\vol\\", "\\$($ONTAP_NETWORK_SHARE_ADDRESS)\"

            $vmGeneration = if ($vm.Firmware -eq "bios") {1} else {2};

            Write-Host "***********************************************"
            Write-Host "Creating VM $($vm.Name)" -ForegroundColor Blue
            Write-Host "***********************************************"
            Write-Host "Creating VM $($vm.Name) with Memory $($vm.MemoryGB)GB, vSwitch $($HYPERV_VM_SWITCH), $($vm.HardDisks[0].Name) ""$($windowsPath)"", Generation $($vmGeneration) on Hyper-V"

            $createVM = Hyper-V\New-VM -Name $vm.Name -VHDPath $windowsPath -SwitchName $HYPERV_VM_SWITCH -MemoryStartupBytes (Invoke-Expression "$($vm.MemoryGB)GB") -Generation $vmGeneration -ErrorAction Stop
            if($createVM) {
                Write-Host "VM $($createVM.Name) created on Hyper-V host`n" -ForegroundColor Green


                $index = 0
                foreach($vmDisk in $vm.HardDisks) {
                    $index++
                    if ($index -eq 1) {
                        continue
                    }

                    Write-Host "`nAttaching $($vmDisk.Name) for VM $($vm.Name)"
                    Write-Host "---------------------------------------------"

                    $originalPath = $vmDisk.VHDXPath

                    # Replace forward slashes with backslashes
                    $windowsPath = $originalPath -replace "/", "\"

                    # Replace the initial part of the path with the Windows drive letter
                    $windowsPath = $windowsPath -replace "^\\vol\\", "\\$($ONTAP_NETWORK_SHARE_ADDRESS)\"

                    try {
                        $attachDisk = Hyper-v\Add-VMHardDiskDrive -VMName $vm.Name -Path $windowsPath -ErrorAction Stop
                        Write-Host "Attached $($vmDisk.Name) ""$($windowsPath)"" to VM $($vm.Name)" -ForegroundColor Green
                    }
                    catch {
                        Write-Error "Failed to attach $($vmDisk.Name) $($windowsPath) to VM $($vm.Name): Error : $($_.Exception.Message)"
                        Break;
                    }
                }

                if($vmGeneration -eq 2 -and $vm.GuestID -like "*rhel*") {
                    try {
                        Write-Host "`nDisabling secure boot"
                        Hyper-V\Set-VMFirmware -VMName $createVM.Name -EnableSecureBoot Off -ErrorAction Stop
                        Write-Host "Secure boot disabled" -ForegroundColor Green
                    }
                    catch {
                        Write-Error "Failed to disable secure boot for VM $($createVM.Name). Error : $($_.Exception.Message)"
                    }
                }

                try {
                    Write-Host "`nStarting VM $($createVM.Name)"
                    Hyper-v\Start-VM -Name $createVM.Name -ErrorAction Stop
                    Write-Host "Started VM $($createVM.Name)`n" -ForegroundColor Green
                }
                catch {
                    Write-Error "Failed to start VM $($createVM.Name). Error : $($_.Exception.Message)"
                    Break;
                }
            }
        }
        catch {
            Write-Error "Failed  to create VM $($vm.Name) on Hyper-V. Error : $($_.Exception.Message)"
            Break;
        }
    }
}

main
----
====